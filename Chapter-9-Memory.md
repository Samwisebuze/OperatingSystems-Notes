# Chapter 9 - Memory

<!-- TOC -->

- [Chapter 9 - Memory](#chapter-9---memory)
	- [9.1 Background](#91-background)
		- [9.1.1 Basic Hardware](#911-basic-hardware)
			- [Base and Limit](#base-and-limit)
		- [9.1.2 Address Binding](#912-address-binding)
		- [9.1.2 Logical Versus Physical Address Space](#912-logical-versus-physical-address-space)
		- [9.1.4 Dynamic Loading](#914-dynamic-loading)
		- [9.1.4 Dynamic Linking and Shared Libraries](#914-dynamic-linking-and-shared-libraries)
	- [9.2 Contiguous Memory](#92-contiguous-memory)
		- [9.2.1 Memory Protection](#921-memory-protection)
		- [9.2.2 Memory Allocation](#922-memory-allocation)
		- [9.2.3 Fragmentation](#923-fragmentation)
	- [9.3 Paging](#93-paging)
		- [9.3.1 Basic Method](#931-basic-method)
		- [9.3.2 Hardware Support](#932-hardware-support)
		- [9.3.3 Protection](#933-protection)
		- [9.3.4 Shared Pages](#934-shared-pages)
	- [9.4 Structure of the Page Table](#94-structure-of-the-page-table)
		- [9.4.1 Hierarchical Paging](#941-hierarchical-paging)
		- [9.4.2 Hashed Page Tables](#942-hashed-page-tables)
		- [9.4.3 Inverted Page Tables](#943-inverted-page-tables)
		- [9.4.4 Oracle SPARC Solaris](#944-oracle-sparc-solaris)
	- [9.5 Swapping](#95-swapping)
		- [9.5.1 Standard Swapping](#951-standard-swapping)
		- [9.5.2 Swapping with Paging](#952-swapping-with-paging)
		- [9.5.3 Swapping on Mobile Systems](#953-swapping-on-mobile-systems)
	- [9.6 Example: Intel 32- and 64-bit Architecture](#96-example-intel-32--and-64-bit-architecture)
		- [9.6.1 IA-32 Architecture](#961-ia-32-architecture)
		- [9.6.2 x86-64](#962-x86-64)
	- [9.7 Example: ARMv8 Architecture](#97-example-armv8-architecture)
	- [9.8 Summary](#98-summary)

<!-- /TOC -->

## 9.1 Background

**Memory consists of a large array of bytes, each with its own address.**

A typical instruction-execution cycle:

- Fetch an instruction from memory
  - CPU check the address in the PC (Program Counter)
- Decode the instruction
  - This may cause operands to be fetched from memory
- Store results back in memory

We can ignore _how_ a program generates memory addresses.

### 9.1.1 Basic Hardware

The CPU can only access Main memory and registers directly. Instructions take memory addresses as arguments, not disk addresses. So Any data that need to be use must be moved from higher level memory into either main memory of a register.

Registers can be accessed within one clock cycle. Accessing main memory takes a transaction over the memory bus, and may take many clock cycles to complete.

When the CPU is waiting on memory accesses necessary to complete and instruction it must **stall**. This is not tolerable due to the frequency of memory references.

The solution to _stalling_ is to have a fast memory **cache** in between the CPU and the Main Memory, usually on the CPU its self.

We are not only concerned with the relative access speed of physical memory, but also ensuring correct operation. We have to protect the operating systems from access by user processes and user processes from one another. This protecton must come from the hardware, as the penalty for the OS intervening is to high.

Hardware can implement this protection in several different ways. The key to all of these methods is ensureing that processes have separate, unique memory spaces. This is done in different ways, but requires the hardware to define a range of safe legal addresses that a process can access.

#### Base and Limit

- Uses two registers, Loaded only by the OS
  - Base Register (BR)
  - Limit Register (LR)
- The BR holds the lowest legal memory address
- The LR holds the largest legal memory address
- The process can access anything between the two registers
  - Making the processes memory size LR-BR = Size
- The CPU compares every address generated by the user with these two registers.

This structure prevents user programs from (intentionally or unintentionally) modifying the code or data structures of either the OS or other User programs.

### 9.1.2 Address Binding

In most cases a user process goes through several steps (some of which are optional) before being executed. Addresses are typically symbolic in the source program. A compiler **binds** these symbolic addresses to relocatable addresses (14 bytes from the beginning of the module). The _linker_ or _loader_ in turn binds the relocatable addresses to absolute addresses. Each binding is a mapping from on addresses space to another.

The binding of instructions and data to memory addresses can be done at any step along the way:

- **Compile Time**
  - If you know where the process will reside in memory at compile time you can generate **absolute code**.
  - If at any time the starting location of this code changes, it will need to be recompiled.

![Figure 9.3](./static/figure9-3.png)

### 9.1.2 Logical Versus Physical Address Space

### 9.1.4 Dynamic Loading

### 9.1.4 Dynamic Linking and Shared Libraries

## 9.2 Contiguous Memory

### 9.2.1 Memory Protection

### 9.2.2 Memory Allocation

### 9.2.3 Fragmentation

## 9.3 Paging

### 9.3.1 Basic Method

### 9.3.2 Hardware Support

### 9.3.3 Protection

### 9.3.4 Shared Pages

## 9.4 Structure of the Page Table

### 9.4.1 Hierarchical Paging

### 9.4.2 Hashed Page Tables

### 9.4.3 Inverted Page Tables

### 9.4.4 Oracle SPARC Solaris

## 9.5 Swapping

### 9.5.1 Standard Swapping

### 9.5.2 Swapping with Paging

### 9.5.3 Swapping on Mobile Systems

## 9.6 Example: Intel 32- and 64-bit Architecture

### 9.6.1 IA-32 Architecture

### 9.6.2 x86-64

## 9.7 Example: ARMv8 Architecture

## 9.8 Summary